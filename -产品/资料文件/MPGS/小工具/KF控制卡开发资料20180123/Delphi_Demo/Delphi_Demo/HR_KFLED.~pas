unit HR_KFLED;

interface

uses
  SysUtils;
    /////-------------------------------------------------------------------
    Function  HexStrToStr(const S:string):string; ////»ù´¡º¯Êý
    Function  MB_CRC16(str:string):string;
    function  StrToHexStr3(const S:string;  b:PByte):PByte;

    /////-------------------------------------------------------------------
    /////--------------------------------------------------------------------
    /////--------------------------------------------------------------------


var
    _CRCHi:Array[0..255] of Byte = ($00, $C1, $81, $40, $01, $C0, $80, $41, $01, $C0, $80, $41,
                                    $00, $C1, $81, $40, $01, $C0, $80, $41, $00, $C1, $81, $40,
                                    $00, $C1, $81, $40, $01, $C0, $80, $41, $01, $C0, $80, $41,
                                    $00, $C1, $81, $40, $00, $C1, $81, $40, $01, $C0, $80, $41,
                                    $00, $C1, $81, $40, $01, $C0, $80, $41, $01, $C0, $80, $41,
                                    $00, $C1, $81, $40, $01, $C0, $80, $41, $00, $C1, $81, $40,
                                    $00, $C1, $81, $40, $01, $C0, $80, $41, $00, $C1, $81, $40,
                                    $01, $C0, $80, $41, $01, $C0, $80, $41, $00, $C1, $81, $40,
                                    $00, $C1, $81, $40, $01, $C0, $80, $41, $01, $C0, $80, $41,
                                    $00, $C1, $81, $40, $01, $C0, $80, $41, $00, $C1, $81, $40,
                                    $00, $C1, $81, $40, $01, $C0, $80, $41, $01, $C0, $80, $41,
                                    $00, $C1, $81, $40, $00, $C1, $81, $40, $01, $C0, $80, $41,
                                    $00, $C1, $81, $40, $01, $C0, $80, $41, $01, $C0, $80, $41,
                                    $00, $C1, $81, $40, $00, $C1, $81, $40, $01, $C0, $80, $41,
                                    $01, $C0, $80, $41, $00, $C1, $81, $40, $01, $C0, $80, $41,
                                    $00, $C1, $81, $40, $00, $C1, $81, $40, $01, $C0, $80, $41,
                                    $00, $C1, $81, $40, $01, $C0, $80, $41, $01, $C0, $80, $41,
                                    $00, $C1, $81, $40, $01, $C0, $80, $41, $00, $C1, $81, $40,
                                    $00, $C1, $81, $40, $01, $C0, $80, $41, $01, $C0, $80, $41,
                                    $00, $C1, $81, $40, $00, $C1, $81, $40, $01, $C0, $80, $41,
                                    $00, $C1, $81, $40, $01, $C0, $80, $41, $01, $C0, $80, $41,
                                    $00, $C1, $81, $40);

   _CRCLo:Array[0..255] of Byte = ( $00, $C0, $C1, $01, $C3, $03, $02, $C2, $C6, $06, $07, $C7,
                                    $05, $C5, $C4, $04, $CC, $0C, $0D, $CD, $0F, $CF, $CE, $0E,
                                    $0A, $CA, $CB, $0B, $C9, $09, $08, $C8, $D8, $18, $19, $D9,
                                    $1B, $DB, $DA, $1A, $1E, $DE, $DF, $1F, $DD, $1D, $1C, $DC,
                                    $14, $D4, $D5, $15, $D7, $17, $16, $D6, $D2, $12, $13, $D3,
                                    $11, $D1, $D0, $10, $F0, $30, $31, $F1, $33, $F3, $F2, $32,
                                    $36, $F6, $F7, $37, $F5, $35, $34, $F4, $3C, $FC, $FD, $3D,
                                    $FF, $3F, $3E, $FE, $FA, $3A, $3B, $FB, $39, $F9, $F8, $38,
                                    $28, $E8, $E9, $29, $EB, $2B, $2A, $EA, $EE, $2E, $2F, $EF,
                                    $2D, $ED, $EC, $2C, $E4, $24, $25, $E5, $27, $E7, $E6, $26,
                                    $22, $E2, $E3, $23, $E1, $21, $20, $E0, $A0, $60, $61, $A1,
                                    $63, $A3, $A2, $62, $66, $A6, $A7, $67, $A5, $65, $64, $A4,
                                    $6C, $AC, $AD, $6D, $AF, $6F, $6E, $AE, $AA, $6A, $6B, $AB,
                                    $69, $A9, $A8, $68, $78, $B8, $B9, $79, $BB, $7B, $7A, $BA,
                                    $BE, $7E, $7F, $BF, $7D, $BD, $BC, $7C, $B4, $74, $75, $B5,
                                    $77, $B7, $B6, $76, $72, $B2, $B3, $73, $B1, $71, $70, $B0,
                                    $50, $90, $91, $51, $93, $53, $52, $92, $96, $56, $57, $97,
                                    $55, $95, $94, $54, $9C, $5C, $5D, $9D, $5F, $9F, $9E, $5E,
                                    $5A, $9A, $9B, $5B, $99, $59, $58, $98, $88, $48, $49, $89,
                                    $4B, $8B, $8A, $4A, $4E, $8E, $8F, $4F, $8D, $4D, $4C, $8C,
                                    $44, $84, $85, $45, $87, $47, $46, $86, $82, $42, $43, $83,
                                    $41, $81, $80, $40);



implementation
                   
function HexToInt (str:string) : word;
var
   i , value : word;
   pos : word;
begin
   value:=0;
   pos:=length(str);
  for i:=1 to pos  do
  begin
      case str[i] of
      'f','F':
              value := value*16+15;
      'e','E':
              value := value*16+14;
      'd','D':
              value := value*16+13;
      'c','C':
              value := value*16+12;
      'b','B':
              value := value*16+11;
      'a','A':
              value := value*16+10;
      '0'..'9':
              value := value*16+ord(str[i])-ord('0');
      else
         result:=value;
         exit;
      end;
   result:=value;
  end;

end;

function hextostring(str: string): string;
var
  s,t:string;
  i,j:integer;
  p:pchar;
begin
   s:='';
   i:=1;
   while i< length(str) do begin
      t:=str[i]+str[i+1];
      s:=s+chr(hextoint(t));
      i:=i+2;
   end;
   result:=s;
end;



function StrToHexStr3(const S:string;  b:PByte):PByte;
//×Ö·û´®×ª»»³É16½øÖÆ×Ö·û´®
var
  I:Integer;
  Len:Integer;
begin
  Len:= Length(S) ;
  Len:= Len div 2;
  for i:= 0 to Len do
    begin
      b^:= HexToInt(Copy(S,i * 2+1,2));
      Inc(b)
    end;
  Result:= b;
end;

function HexStrToStr(const S:string):string;
//16½øÖÆ×Ö·û´®×ª»»³É×Ö·û´®
var
  t:Integer;
  ts:string;
  M,Code:Integer;
begin
  t:=1;
  Result:='';
  while t<=Length(S) do
  begin   //xlh 2006.10.21
    while (t<=Length(S)) and (not (S[t] in ['0'..'9','A'..'F','a'..'f'])) do
      inc(t);
    if (t+1>Length(S))or(not (S[t+1] in ['0'..'9','A'..'F','a'..'f'])) then
      ts:='$'+S[t]
    else
      ts:='$'+S[t]+S[t+1];
    Val(ts,M,Code);
    if Code=0 then
      Result:=Result+Chr(M);
    inc(t,2);
  end;
end;

//unction  MB_CRC16( pLedStr:PByte; len:Word ):Word;
Function  MB_CRC16( str:string ):String;
var
   CRCHI:Byte;
   CRCLo:Byte;
   index:integer;
   CRCHITemp:Word;
   Len:Integer;
   i:integer;
   Ret1:string;
   Ret2:string;
   Data:PByteArray;
   pByte1:pByte;
   C1,C2:Byte;
   temp:string;
   Int:integer;
begin
  // str:='0064FFFF3000';
   len:= Length(str);
   len:= Len div 2;
   Data:=GetMemory(len);
   Try
     for i:= 0 to len -1 do
       begin
         //    Data:PByteArray;
         temp:= Copy(str,i*2 +1,2);
         Int:= HexToInt(Temp);
         Data[i]:= Int;
       end;
      pByte1:= Pointer(Data);
      CRCHi:=$FF;
      CRCLo:=$FF;
      if len > 0 then
      begin
        repeat
          index:= CRCLo Xor pByte1^;
          Inc(pByte1);
          CRCLo:= CRCHi xor _CRCHi[index];
          CRCHI:= _CRCLo[index];
          Dec(len);
        until len =0 ;
      end;
      CRCHITemp:=   Word(CRCHI) shl 8;
      CRCHITemp:=   Word(CRCHITemp) or Word(CRCLo);
      C1:= byte(CRCHITemp and $00ff);
      C2:= byte((CRCHITemp shr 8) and $00ff);
      Result:= IntToHex(C1,2) + IntToHex(C2,2);
   finally
       FreeMemory(Data);
   end;

end;

//////////////////----------------------------------------------------------------------------------------------



end.
